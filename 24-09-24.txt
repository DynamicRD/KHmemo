상수는 가독화해라 

리팩토링:		코드를 간결하게 만드는 행위

객체의 3대 특성: 캡슐화

부모의 생성자가 메소드 생성자일시 자식이 부모의 생성자의 값을 책임져줘야한다.

부모가 디폴트 생성자이면 자식은 디생 매생이가능하다
부모가 매생이면 자식은 매생이다

오버라이딩: 	접근제어자, 리턴값, 함수명,매개변수,예외처리 같음
		부모의 멤버변수나 필드가 마음에 안들면 자식이 똑같이 만들어서 씀
		예외처리는 커야한다.
		오버라이딩에서 함수를 콜하면 밑에게 실행된다	
		부모껄 부르려면 super.메소드
		근데 오버라이딩 한순간 부모클래스를 생각이 없다
		메인함수에서도 못부름
		(다형성)

@(어노테이션):	컴파일러에게 이 문장을 실행하기 전에 미리 점검을 해줌

참조변수 주소에는 영역이 있다.
번지에는 영역이 숨어있음( 대상체라고 부름)

부모 객체참조변수는 자신이 포함된 영역가져간다.
자기 영역이 있는(업캐스팅)하는 상황에만 쓰임 
대상체
Dog dog = new Dog();
Animal a = dog;
a는 자식 객체를 호출할수 없지만 오버라이딩은 예외다(다형성)

부모[] 부모변수 = new 부모[] {new 자식1( ),new 자식2( ),new 자식3( )};
for(i;i<4;i++)
{
	부모변수[i].휘둘러();
}

C++에서 메모리를 감추고 다중상속 지원을 멈춘게 JAVA

다형성:		자식클래스가 부모클래스를 상속관계를 받을때 자식이 부모 메소드(추상메소드)를 오버라이딩한다면
		부모객체참조변수로 그 오버라이딩된 함수를 부르면 각 자식들의 함수가 로딩되는거를
		다형성이라고 말합니다.
		부모 객체참조변수로 자식 객체참조변수를 받을 수 있다.
		1.상속클래스 구현
		2.메소드 오버라이딩
		3.업스캐스팅 구현

추상메소드: 	함수의 선언부만 있고 구현부가 없다.
		자식이 오버라이딩해서 구현한다

인터페이스를 만들고 상속받으면(임플리먼트) 자식클래스들이 지시에 안따르면 실행이안됨

캡슐화정책,상속,자식은 부모를 책임져야함

부모객체배열짜고 자식객체 선언,반복문

제네릭과 컬렉션
면접자주)컬렉션 프로그램에 대해 설명하시오
컬렉션 프레임워크: 배열의 문제점을 개선하기위해 만든프레임워크
배열은 확장성이 제로,메모리 낭비,기능의 제약라는 단점이 있다
웹프로그램에서 주로 쓴다.
컬렉션: ArrayList, Map(hash table), set, stack, quene
제네릭:		만능 객체 E

ArrayList<자료형> sList = new ArrayList<자료형>( );
기본 베이스가 10개 *1.5단위로 증가함,올림처리
원소 추가 : list.add(추가할거)
	  list.add(4,추가할거) 	//4번째에 추가 (4,5번이 뒤로 밀린다)
	  list.set(4,추가할거)	//4번째를 수정
	  list.set(4,추가할거)	//4번째를 삭제

length는 ArrayList.size() 이용
찾는건 .get()